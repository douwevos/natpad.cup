package net.natpad.cup.export.java;

import java.io.IOException;
import java.io.PrintWriter;

import net.natpad.cup.export.java.ast.AstJava;
import net.natpad.cup.model.bnf.BnfModel;
import net.natpad.cup.model.bnf.NonTerminal;
import net.natpad.cup.model.bnf.Terminal;

public class SymbolExporter {

	public final JavaExportInfo exportInfo;
	public final BnfModel model;
	
	public SymbolExporter(BnfModel model, JavaExportInfo exportInfo) {
		this.exportInfo = exportInfo;
		this.model = model;
	}

	public void doExport(boolean emit_non_terms, boolean sym_interface) throws IOException {
		AstJava astJava = new AstJava();
		astJava.setClassName(exportInfo.symbolClass);

		PrintWriter out = astJava.openClass(exportInfo.destDir);
		
//		PrintWriter out = symbol_class_file;
		String class_or_interface = (sym_interface) ? "interface" : "class";

//
//		/* top of file */
//		out.println();
//		out.println("//----------------------------------------------------");
//		out.println("// The following code was generated by " + Version.title_str);
//		out.println("// " + new Date());
//		out.println("//----------------------------------------------------");
//		out.println();
//		emitPackage(out);

		/* class header */
//		out.println("/** CUP generated " + class_or_interface + " containing symbol constants. */");
//		out.println("public " + class_or_interface + " " + symbol_const_class_name + " {");

		out.println("  /* terminals */");

		/* walk over the terminals *//* later might sort these */
		for (Terminal term : model.terminals) {

			/* output a constant decl for the terminal */
			out.println("  public static final int " + term.name() + " = " + term.index() + ";");
		}

		/* do the non terminals if they want them (parser doesn't need them) */
		if (emit_non_terms) {
			out.println();
			out.println("  /* non terminals */");

			/* walk over the non terminals *//* later might sort these */
			for (NonTerminal nonTerm : model.nonTerminals) {
				/* output a constant decl for the terminal */
				out.println("  static final int " + nonTerm.name() + " = " + nonTerm.index() + ";");
			}
		}

		astJava.closeClass(out);
		
	}
	
}
