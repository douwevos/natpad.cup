package net.natpad.cup.export.java;

import java.io.IOException;
import java.io.PrintWriter;

import net.natpad.cup.FatalCupException;
import net.natpad.cup.ParseActionRow;
import net.natpad.cup.ParseActionTable;
import net.natpad.cup.ParseReduceTable;
import net.natpad.cup.export.java.ast.AstClassName;
import net.natpad.cup.export.java.ast.AstJava;
import net.natpad.cup.model.bnf.BnfModel;
import net.natpad.cup.model.bnf.Production;
import net.natpad.cup.state.LalrState;
import net.natpad.cup.state.ParseAction;
import net.natpad.cup.state.ReduceAction;
import net.natpad.cup.state.ShiftAction;

public class ParserExporter {

	public final JavaExportInfo exportInfo;
	public final BnfModel model;
	
	public ParserExporter(BnfModel model, JavaExportInfo exportInfo) {
		this.exportInfo = exportInfo;
		this.model = model;
	}
	
	
	
	/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

	/**
	 * Emit the parser subclass with embedded tables.
	 * 
	 * @param out stream to produce output on.
	 * @param action_table internal representation of the action table.
	 * @param reduce_table internal representation of the reduce-goto table.
	 * @param start_st start state of the parse machine.
	 * @param start_prod start production of the grammar.
	 * @param compact_reduces do we use most frequent reduce as default?
	 * @throws IOException 
	 */
	public void doExport(ParseActionTable action_table, ParseReduceTable reduce_table, int start_st,
					Production start_prod, boolean compact_reduces) throws IOException {
		
		
		AstJava astJava = new AstJava();
		astJava.setClassName(exportInfo.parserClass);
		astJava.setExtends(exportInfo.parserRuntimeClass);
		
		
		for(String importName : Emit.getImportList()) {
			astJava.addImport(new AstClassName(importName));
		}

		astJava.addImport(new AstClassName("java.lang.Exception"));
		astJava.addImport(exportInfo.symbolRuntimeClass);
		astJava.addImport(exportInfo.contextRuntimeClass);
		

		PrintWriter out = astJava.openClass(exportInfo.destDir);


//		/* top of file */
//		out.println();
//		out.println("//----------------------------------------------------");
//		out.println("// The following code was generated by " + Version.title_str);
//		out.println("// " + new Date());
//		out.println("//----------------------------------------------------");
//		out.println();
//		emitPackage(out);
//
//		/* user supplied imports */
//		for (int i = 0; i < import_list.size(); i++)
//			out.println("import " + import_list.elementAt(i) + ";");
//		/* class header */
//		out.println();
//		out.println("/** " + Version.title_str + " generated parser.");
//		out.println("  * @version " + new Date());
//		out.println("  */");
//		out.println("public class " + parser_class_name + " extends java_cup.runtime.lr_parser {");

		/* constructors [CSA/davidm, 24-jul-99] */
		out.println();
		out.println("	public " + exportInfo.parserClass.className + "() {}");

		/* emit the various tables */
		emitProductionTable(model, out);
		doActionTable(out, action_table, compact_reduces);
		doReduceTable(out, reduce_table);

		/* instance of the action encapsulation class */
		out.println("	/** Instance of action encapsulation class. */");
		out.println("	protected " + exportInfo.actionClass.className + " actionObject;");
		out.println();

		/* action object initializer */
		out.println("	/** Action encapsulation object initializer. */");
		out.println("	protected void initActions() {");
		out.println("		actionObject = new " + exportInfo.actionClass.className + "();");
		out.println("	}");
		out.println();

		/* access to action code */
		out.println("	/** Invoke a user supplied parse action. */");
		out.println("	public "+exportInfo.symbolRuntimeClass.className+" runAction("+exportInfo.contextRuntimeClass.className+" parserContext, int actionId) throws Exception {");
		out.println("		/* call code in generated class */");
		out.println("		return actionObject.runAction(parserContext, actionId);");
		out.println("	}");
		out.println("");

		/* method to tell the parser about the start state */
		out.println("	/** Indicates start state. */");
		out.println("	public int startState() {");
		out.println("		return " + start_st + ";");
		out.println("	}");

		/* method to indicate start production */
		out.println("	/** Indicates start production. */");
		out.println("	public int startProduction() {");
		out.println("		return " + model.getStartProduction().index() + ";");
		out.println("	}");
		out.println();

		/* methods to indicate EOF and error symbol indexes */
		out.println("	/** <code>EOF</code> Symbol index. */");
		out.println("	public int eofSymbol() {");
		out.println("		return " + model.EOF.index() + ";");
		out.println("	}");
		out.println();
		out.println("	/** <code>error</code> Symbol index. */");
		out.println("	public int errorSymbol() {");
		out.println("		return " + model.error.index() + ";");
		out.println("	}");
		out.println();

		/* user supplied code for user_init() */
		if (Emit.getInitCode() != null) {
			out.println();
			out.println("	/** User initialization code. */");
			out.println("	public void userInit() throws Exception {");
			out.println(Emit.getInitCode());
			out.println("	}");
		}

		/* user supplied code */
		if (Emit.getParserCode() != null) {
			out.println();
			out.println(Emit.getParserCode());
		}


//		/* put out the action code class */
//		emitActionCode(model, out, start_prod);

		astJava.closeClass(out);

	}

	/*-----------------------------------------------------------*/

	
	/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

	/**
	 * Emit the production table.
	 * 
	 * @param out stream to produce output on.
	 */
	protected void emitProductionTable(BnfModel model, PrintWriter out) {
		Production all_prods[];

		/* collect up the productions in order */
		all_prods = new Production[model.productions.count()];
		for (Production prod : model.productions) {
			all_prods[prod.index()] = prod;
		}

		// make short[][]
		short[][] prod_table = new short[model.productions.count()][2];
		for (int i = 0; i < model.productions.count(); i++) {
			Production prod = all_prods[i];
			// { lhs symbol , rhs size }
			prod_table[i][0] = (short) prod.lhs().getSymbol().index();
			prod_table[i][1] = (short) prod.rhsLength();
		}
		/* do the top of the table */
		out.println();
		out.println("	/** Production table. */");
		out.println("	protected static final short productionTable[][] = ");
		doTableAsString(out, prod_table);

		/* do the public accessor method */
		out.println();
		out.println("	/** Access to production table. */");
		out.println("	public short[][] getProductionTable() {");
		out.println("		return productionTable;");
		out.println("	}");

//		production_table_time = System.currentTimeMillis() - start_time;
	}
	

	
	/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

	/**
	 * Emit the action table.
	 * 
	 * @param out stream to produce output on.
	 * @param act_tab the internal representation of the action table.
	 * @param compact_reduces do we use the most frequent reduce as default?
	 */
	protected void doActionTable(PrintWriter out, ParseActionTable act_tab, boolean compact_reduces) {
		ParseActionRow row;
		ParseAction act;
		int red;


		/* collect values for the action table */
		short[][] action_table = new short[act_tab.num_states()][];
		/* do each state (row) of the action table */
		for (int i = 0; i < act_tab.num_states(); i++) {
			/* get the row */
			row = act_tab.under_state[i];

			/* determine the default for the row */
			if (compact_reduces)
				row.compute_default();
			else
				row.default_reduce = -1;

			/* make temporary table for the row. */
			short[] temp_table = new short[2 * row.size()];
			int nentries = 0;

			/* do each column */
			for (int j = 0; j < row.size(); j++) {
				/* extract the action from the table */
				act = row.under_term[j];

				/* skip error entries these are all defaulted out */
				if (act.kind() != ParseAction.ERROR) {
					/* first put in the symbol index, then the actual entry */

					/* shifts get positive entries of state number + 1 */
					if (act.kind() == ParseAction.SHIFT) {
						/* make entry */
						temp_table[nentries++] = (short) j;
						temp_table[nentries++] = (short) (((ShiftAction) act).shift_to().index() + 1);
					}

					/* reduce actions get negated entries of production# + 1 */
					else if (act.kind() == ParseAction.REDUCE) {
						/* if its the default entry let it get defaulted out */
						red = ((ReduceAction) act).reduce_with().index();
						if (red != row.default_reduce) {
							/* make entry */
							temp_table[nentries++] = (short) j;
							temp_table[nentries++] = (short) (-(red + 1));
						}
					} else if (act.kind() == ParseAction.NONASSOC) {
						/* do nothing, since we just want a syntax error */
					} else {
					/* shouldn't be anything else */
						throw new FatalCupException("Unrecognized action code " + act.kind() + " found in parse table");
					}
				}
			}

			/* now we know how big to make the row */
			action_table[i] = new short[nentries + 2];
			System.arraycopy(temp_table, 0, action_table[i], 0, nentries);

			/* finish off the row with a default entry */
			action_table[i][nentries++] = -1;
			if (row.default_reduce != -1)
				action_table[i][nentries++] = (short) (-(row.default_reduce + 1));
			else
				action_table[i][nentries++] = 0;
		}

		/* finish off the init of the table */
		out.println();
		out.println("	/** Parse-action table. */");
		out.println("	protected static final short[][] actionTable = ");
		doTableAsString(out, action_table);

		/* do the public accessor method */
		out.println();
		out.println("  /** Access to parse-action table. */");
		out.println("	public short[][] getActionTable() {");
		out.println("		return actionTable;");
		out.println("	}");
//		action_table_time = System.currentTimeMillis() - start_time;
	}

	/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

	
	/**
	 * Emit the reduce-goto table.
	 * 
	 * @param out stream to produce output on.
	 * @param red_tab the internal representation of the reduce-goto table.
	 */
	protected void doReduceTable(PrintWriter out, ParseReduceTable red_tab) {
		LalrState goto_st;


		/* collect values for reduce-goto table */
		short[][] reduce_goto_table = new short[red_tab.num_states()][];
		/* do each row of the reduce-goto table */
		for (int i = 0; i < red_tab.num_states(); i++) {
			/* make temporary table for the row. */
			short[] temp_table = new short[2 * red_tab.under_state[i].size()];
			int nentries = 0;
			/* do each entry in the row */
			for (int j = 0; j < red_tab.under_state[i].size(); j++) {
				/* get the entry */
				goto_st = red_tab.under_state[i].under_non_term[j];

				/* if we have none, skip it */
				if (goto_st != null) {
					/* make entries for the index and the value */
					temp_table[nentries++] = (short) j;
					temp_table[nentries++] = (short) goto_st.index();
				}
			}
			/* now we know how big to make the row. */
			reduce_goto_table[i] = new short[nentries + 2];
			System.arraycopy(temp_table, 0, reduce_goto_table[i], 0, nentries);

			/* end row with default value */
			reduce_goto_table[i][nentries++] = -1;
			reduce_goto_table[i][nentries++] = -1;
		}

		/* emit the table. */
		out.println();
		out.println("	/** <code>reduce_goto</code> table. */");
		out.println("	protected static final short[][] reduceTable = ");
		doTableAsString(out, reduce_goto_table);

		/* do the public accessor method */
		out.println();
		out.println("	/** Access to <code>reduce_goto</code> table. */");
		out.println("	public short[][] getReduceTable() {");
		out.println("		return reduceTable;");
		out.println("	}");
		out.println();

	}
	
	

//	/**
//	 * Emit code for the non-public class holding the actual action code.
//	 * 
//	 * @param out stream to produce output on.
//	 * @param start_prod the start production of the grammar.
//	 */
//	protected void emitActionCode(Model model, PrintWriter out, Production start_prod) {
//
//		long start_time = System.currentTimeMillis();
//
//		/* class header */
//		out.println();
//		out.println("/** Cup generated class to encapsulate user supplied action code.*/");
//		out.println("class " + exportInfo.prefix("actions") + " {");
//
//		/* user supplied code */
//		if (Emit.action_code != null) {
//			out.println();
//			out.println(Emit.action_code);
//		}
//
//		/* field for parser object */
//		out.println("	private final " + exportInfo.parserClass.className + " parser;");
//
//		/* constructor */
//		out.println();
//		out.println("	" + exportInfo.prefix("actions") + "(" + exportInfo.parserClass.className + " parser) {");
//		out.println("		this.parser = parser;");
//		out.println("	}");
//
//		/* action method head */
//		out.println();
//		out.println("	/** Method with the actual generated action code. */");
//		out.print("	public final "+exportInfo.symbolRuntimeClass.className+" " + exportInfo.prefix("do_action") + "(int " + exportInfo.prefix("act_num"));
//		out.print(", "+exportInfo.parserRuntimeClass.className+" " + exportInfo.prefix("parser"));
//		out.print(", Stack " + exportInfo.prefix("stack"));
//		out.print(", int " + exportInfo.prefix("top)"));
//		out.println(" throws Exception {");
//
//		/* declaration of result symbol */
//		/*
//		 * New declaration!! now return Symbol 6/13/96 frankf
//		 */
//		out.println("	/* Symbol object for return from actions */");
//		out.println("	"+exportInfo.symbolRuntimeClass.className+" " + exportInfo.prefix("result") + ";");
//		out.println();
//
//		/* switch top */
//		out.println("	/* select the action based on the action number */");
//		out.println("	switch (" + exportInfo.prefix("act_num") + ") {");
//
//		/* emit action code for each production as a separate case */
//		for (Production prod : model.productions) {
//			/* case label */
//			out.println("		case " + prod.index() + ": { // " + prod.toSimpleString());
//
//			/* create the result symbol */
//			/*
//			 * make the variable RESULT which will point to the new Symbol (see below) and be changed by action code
//			 * 6/13/96 frankf
//			 */
//			out.println("			" + prod.lhs().getSymbol().stack_type() + " RESULT = null;");
//
//			/*
//			 * Add code to propagate RESULT assignments that occur in action code embedded in a production (ie,
//			 * non-rightmost action code). 24-Mar-1998 CSA
//			 */
//			for (int i = 0; i < prod.rhsLength(); i++) {
//				// only interested in non-terminal symbols.
//				if (!(prod.rhs(i) instanceof SymbolPart))
//					continue;
//				Symbol s = ((SymbolPart) prod.rhs(i)).getSymbol();
//				if (!(s instanceof NonTerminal))
//					continue;
//				// skip this non-terminal unless it corresponds to
//				// an embedded action production.
//				if (((NonTerminal) s).is_embedded_action == false)
//					continue;
//				// OK, it fits. Make a conditional assignment to RESULT.
//				int index = prod.rhsLength() - i - 1; // last rhs is on top.
//				out.println("			" + "// propagate RESULT from " + s.name());
//				out.println("			" + "if ( " + "(("+exportInfo.symbolRuntimeClass.className+") " + exportInfo.prefix("stack")
//								+ ".elementAt(" + exportInfo.prefix("top") + "-" + index + ")).value != null ) {");
//				out.println("				" + "RESULT = " + "(" + prod.lhs().getSymbol().stack_type() + ") "
//								+ "(("+exportInfo.symbolRuntimeClass.className+") " + exportInfo.prefix("stack") + ".elementAt(" + exportInfo.prefix("top")
//								+ "-" + index + ")).value;");
//				out.println("			}");
//			}
//
//			
//			List<ActionDeclaration> declarations = prod.getDeclarations();
//			if (declarations!=null) {
//				for(ActionDeclaration declaration : declarations) {
//					makeDeclaration(declaration, out);
//				}
//			}
//			
//			/* if there is an action string, emit it */
//			if (prod.action() != null && prod.action().code_string() != null && !prod.action().equals(""))
//				out.println(prod.action().code_string());
//
//			/*
//			 * here we have the left and right values being propagated. must make this a command line option. frankf
//			 * 6/18/96
//			 */
//
//			/*
//			 * Create the code that assigns the left and right values of the new Symbol that the production is reducing
//			 * to
//			 */
//			if (Emit.lr_values()) {
//				int loffset;
//				String leftstring, rightstring;
//				int roffset = 0;
//				rightstring = "(("+exportInfo.symbolRuntimeClass.className+")" + exportInfo.prefix("stack") + ".elementAt(" + exportInfo.prefix("top") + "-"
//								+ roffset + ")).right";
//				if (prod.rhsLength() == 0) {
//					leftstring = rightstring;
//				} else {
//					loffset = prod.rhsLength() - 1;
//					leftstring = "(("+exportInfo.symbolRuntimeClass.className+")" + exportInfo.prefix("stack") + ".elementAt(" + exportInfo.prefix("top")
//									+ "-" + loffset + ")).left";
//				}
//				out.println("			" + exportInfo.prefix("result") + " = new "+exportInfo.symbolRuntimeClass.className+"("
//								+ prod.lhs().getSymbol().index() + "/*" + prod.lhs().getSymbol().name() + "*/" + ", "
//								+ leftstring + ", " + rightstring + ", RESULT);");
//			} else {
//				out.println("			" + exportInfo.prefix("result") + " = new "+exportInfo.symbolRuntimeClass.className+"("
//								+ prod.lhs().getSymbol().index() + "/*" + prod.lhs().getSymbol().name() + "*/"
//								+ ", RESULT);");
//			}
//			out.println("		}");
//
//			/* if this was the start production, do action for accept */
//			if (prod == start_prod) {
//				out.println("		/* ACCEPT */");
//				out.println("		" + exportInfo.prefix("parser") + ".done_parsing();");
//			}
//
//			/* code to return lhs symbol */
//			out.println("		return " + exportInfo.prefix("result") + ";");
//			out.println();
//		}
//
//		/* end of switch */
//		out.println("		default:");
//		out.println("			throw new Exception(\"Invalid action number found in internal parse table\");");
//		out.println("		}");
//
//		/* end of method */
//		out.println("	}");
//
//		out.println();
//
//		Emit.action_code_time = System.currentTimeMillis() - start_time;
//	}

	
	
//
//	/**
//	 * Return label declaration code
//	 * 
//	 * @param labelname    the label name
//	 * @param stack_type   the stack type of label?
//	 * @author frankf
//	 */
//	public void makeDeclaration(ActionDeclaration declaration, PrintWriter out) {
//		/* Put in the left/right value labels */
//		if (Emit.lr_values()) {
//			out.println("			int " + declaration.label + "left = (("+exportInfo.symbolRuntimeClass.className+")" + exportInfo.prefix("stack") + ".elementAt("+ exportInfo.prefix("top") + "-" + declaration.offset + ")).left;");
//			out.println("			int " + declaration.label + "right = (("+exportInfo.symbolRuntimeClass.className+")" + exportInfo.prefix("stack") + ".elementAt("+ exportInfo.prefix("top") + "-" + declaration.offset + ")).right;");
//		}
//
//		/* otherwise, just declare label. */
//		out.println("			" + declaration.stackType + " " + declaration.label + " = (" + declaration.stackType + ")((" + exportInfo.symbolRuntimeClass.className+") "
//						+ exportInfo.prefix("stack") + ".elementAt(" + exportInfo.prefix("top") + "-" + declaration.offset + ")).value;");
//
//	}
//	


	
	// print a string array encoding the given short[][] array.
	private void doTableAsTable(PrintWriter out, short[][] sa) {
	    out.println("	new short[][] {");
	    int nchar=0, nbytes=0;
	    for (int i=0; i<sa.length; i++) {
	    	out.print("		new short[] { ");
	    	for (int j=0; j<sa[i].length; j++) {
	    		if (j>0) {
	    			out.print(", ");
	    		}
	    		out.print(""+sa[i][j]);
	    	}
	    	if (i==sa.length-1) {
	    		out.println(" }");
	    	} else {
	    		out.println(" },");
	    	}
	    		
	    }
	    out.print(" };");
	}

	
	
	// print a string array encoding the given short[][] array.
	protected void doTableAsString(PrintWriter out, short[][] sa) {
		doTableAsTable(out, sa);
	}

	
	protected void doTableAsPackedString(PrintWriter out, short[][] sa) {
		out.print("			unpackFromStrings(");
		out.println("new String[] {");
		out.print("    \"");
		int nchar = 0, nbytes = 0;
		nbytes += do_escaped(out, (char) (sa.length >> 16));
		nchar = doNewLine(out, nchar, nbytes);
		nbytes += do_escaped(out, (char) (sa.length & 0xFFFF));
		nchar = doNewLine(out, nchar, nbytes);
		for (int i = 0; i < sa.length; i++) {
			nbytes += do_escaped(out, (char) (sa[i].length >> 16));
			nchar = doNewLine(out, nchar, nbytes);
			nbytes += do_escaped(out, (char) (sa[i].length & 0xFFFF));
			nchar = doNewLine(out, nchar, nbytes);
			for (int j = 0; j < sa[i].length; j++) {
				// contents of string are (value+2) to allow for common -1, 0
				// cases
				// (UTF-8 encoding is most efficient for 0<c<0x80)
				nbytes += do_escaped(out, (char) (2 + sa[i][j]));
				nchar = doNewLine(out, nchar, nbytes);
			}
		}
		out.print("\" }");
		out.println(");");
		
	}

	// split string if it is very long; start new line occasionally for neatness
	protected int doNewLine(PrintWriter out, int nchar, int nbytes) {
		if (nbytes > 65500) {
			out.println("\", ");
			out.print("    \"");
		} else if (nchar > 11) {
			out.println("\" +");
			out.print("    \"");
		} else
			return nchar + 1;
		return 0;
	}

	// output an escape sequence for the given character code.
	protected int do_escaped(PrintWriter out, char c) {
		StringBuffer escape = new StringBuffer();
		if (c <= 0xFF) {
			escape.append(Integer.toOctalString(c));
			while (escape.length() < 3)
				escape.insert(0, '0');
		} else {
			escape.append(Integer.toHexString(c));
			while (escape.length() < 4)
				escape.insert(0, '0');
			escape.insert(0, 'u');
		}
		escape.insert(0, '\\');
		out.print(escape.toString());

		// return number of bytes this takes up in UTF-8 encoding.
		if (c == 0)
			return 2;
		if (c >= 0x01 && c <= 0x7F)
			return 1;
		if (c >= 0x80 && c <= 0x7FF)
			return 2;
		return 3;
	}
	
	
}
